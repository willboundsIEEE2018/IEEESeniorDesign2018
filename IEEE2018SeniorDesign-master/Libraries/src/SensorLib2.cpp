#include <stdlib.h>
#include <stdio.h>
#include <unistd.h>
#include <stdint.h>
#include <stdbool.h>
#include <linux/i2c-dev.h>
#include <fcntl.h>
#include "Adafruit_VL6180x.h"
#include "VL53L0X.h"
#include "ledRead.h"
#include "RTIMULib.h"
#include "RTMath.h"
#include "SensorLib2.h"

//Private Helper prototypes
//I2C Expander
int getMUXStatus(MUX *);
void setMUXStatus(MUX *, int);
int getMUXInput(MUX *);
void setMUXInput(MUX *, int);

/* I2C Expander MUX */
/*
 * Initialize the MUX
 *
 * This function initializes the I2C Expander and returns
 * a MUX object
 *
 */
MUX *initMUX() {
    MUX *newMUX = (MUX *) malloc(sizeof(MUX));
    char buf[15];
    newMUX->muxStatus = open(buf,O_RDWR);
    if (ioctl(newMUX->muxStatus,I2C_SLAVE,0x70)<0) {
	printf("MUX initialization failed\n");
	setMUXStatus(newMUX,-1);
	return newMUX;
    }
    else {
	setMUXStatus(newMUX,0);
	switchMUX(newMUX,0);
	return newMUX;
    }
}

/*
 * Changes the active input of the I2C Expander
 * to the inputNo specified by user
 */
void switchMUX(MUX *mux, int inputNo) {
    if(!getMUXStatus(mux)) {
        char data_write[1];
        data_write[0] = 1<<inputNo;
        write(mux->muxStatus, data_write, 1);
	setMUXInput(mux,1);
    }
    else {
	printf("Cannot switch MUX, status error\n");
    }
}

/* VL6180X */
/*
 *
 * Initializer for the short range VL6180X  
 *
 */
SRANGE *initVL6180X(MUX *mux,int inputNo) {
    SRANGE *newSRANGE = (SRANGE *) malloc(sizeof(SRANGE));
    newSRANGE->vl = Adafruit_VL6180X();
    newSRANGE->mux=mux;
    newSRANGE->inputNo=inputNo;
    return newSRANGE;
}

/*
 *
 * Gets the distance in mm for VL6180X
 *
 * Gets the distance from the short range TOF
 * specified by the user
 */
uint8_t getShortRange(SRANGE *srange) {
    if (!getMUXStatus(srange->mux)) {
	//switch MUX input if needed
	if (getMUXInput(srange->mux)!=srange->inputNo)
	    switchMUX(srange->mux,srange->inputNo);
	srange->range=srange->vl.readRange();
	srange->status=srange->vl.readRangeStatus();
    }
    else {
	srange->range=-1;
	srange->status=-1;
    }
    return srange->range;
}


/* VL53L0X */
/*
 * Initializes the VL53L0X TOF
 *
 * Function returns a LRANGE object
 */
LRANGE *initLongrange(MUX *mux, int inputNo) {
    LRANGE *lrange=(LRANGE *) malloc(sizeof(LRANGE));
    VL53L0X vl;
    vl.init();
    vl.setTimeout(200);
    lrange->vl53l0x=vl;
    lrange->mux=mux;
    lrange->inputNo=inputNo;
    return lrange;
}

uint16_t getLongRange(LRANGE *lrange) {
    if (!getMUXStatus(lrange->mux)) {
	//switch MUX input if needed
	if (getMUXInput(lrange->mux)!=lrange->inputNo)
	    switchMUX(lrange->mux,lrange->inputNo);
    }
    uint16_t distance = lrange->vl53l0x.readRangeSingleMillimeters();
    if (lrange->vl53l0x.timeoutOccurred())
	printf("Timeout occurred. Invalid measurement.\n");
    return distance;
}



/*TOF*/
TOF *newTOF(int rangeType,MUX *mux,int input) {
    TOF *tof=(TOF *) malloc(sizeof(TOF));
    //rangeType 0 = short range
    // 		1 = long range
    if (rangeType==0)
    {
	SRANGE *srange=initVL6180X(mux,input);
	tof->srange=srange;
	tof->isLRANGE=rangeType;
	tof->mux=mux;
	tof->inputNo=input;
    }
    else if(rangeType==1)
    {
	LRANGE *lrange=initLongRange(mux,input);
	tof->lrange=lrange;
	tof->isLRANGE=rangeType;
	tof->mux=mux;
	tof->inputNo=input;
    }
    else {
    	printf("Invalid range type for TOF\n");
	return NULL;
    }
    return tof;
}

int isLRANGE(TOF *tof) {
    return tof->isLRANGE;
}

int getDistance(TOF *tof) {
    int distance;
    if (isLRANGE(tof)) {
	LRANGE *lrtof=tof->lrange;
	distance=lrtof->vl53l0x.readRangeSingleMillimeters();
    }
    else {
	SRANGE *srtof=tof->srange;
	distance=srtof->vl.readRange();
    }
    return distance;
}


/* IRLED READER */
int readIRCode()
{
    return ledRead();
}


/* IMU */
RTIMU *imuInit() {
    //  Using RTIMULib here allows it to use the .ini file generated by RTIMULibDemo.
    //  Or, you can create the .ini in some other directory by using:
    //      RTIMUSettings *settings = new RTIMUSettings("<directory path>", "RTIMULib");
    //  where <directory path> is the path to where the .ini file is to be loaded/saved


    RTIMUSettings *settings = new RTIMUSettings("RTIMULib");

    RTIMU *imu = RTIMU::createIMU(settings);

    if ((imu == NULL) || (imu->IMUType() == RTIMU_TYPE_NULL)) {
        printf("No IMU found\n");
        exit(1);
    }

    //  This is an opportunity to manually override any settings before the call IMUInit

    //  set up IMU

    imu->IMUInit();

    //  this is a convenient place to change fusion parameters

    imu->setSlerpPower(0.02);
    imu->setGyroEnable(true);
    imu->setAccelEnable(true);
    imu->setCompassEnable(false);
    return imu;
}

double getCurrImuRoll(RTIMU *imu) {
    RTIMU_DATA imuData = imu->getIMUData();
    RTVector3 vec=imuData.fusionPose;
    double roll=vec.x() * RTMATH_RAD_TO_DEGREE;
    printf("current:%f \n",roll);
    return roll;
}

double getCurrImuPitch(RTIMU *imu) {
    RTIMU_DATA imuData = imu->getIMUData();
    RTVector3 vec=imuData.fusionPose;
    double pitch=vec.x() * RTMATH_RAD_TO_DEGREE;
    printf("current:%f \n",pitch);
    return pitch;
}

double getCurrImuYaw(RTIMU *imu) {
    RTIMU_DATA imuData = imu->getIMUData();
    RTVector3 vec=imuData.fusionPose;
    double yaw=vec.z() * RTMATH_RAD_TO_DEGREE; 
    printf("current:%f  \n",yaw);
    return yaw;
}

//Private Helper methods
int getMUXStatus(MUX *mux) {
    return mux->initVal;
}
void setMUXStatus(MUX *mux, int val) {
    mux->initVal=val;
}
int getMUXInput(MUX *mux) {
    return mux->activeInput;
}
void setMUXInput(MUX *mux, int val) {
    mux->activeInput=val;
}
