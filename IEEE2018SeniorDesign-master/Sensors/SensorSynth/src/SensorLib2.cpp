#include <stdlib.h>
#include <stdio.h>
#include <unistd.h>
#include <stdint.h>
#include <stdbool.h>
#include <linux/i2c-dev.h>
#include <fcntl.h>
#include "Adafruit_VL6180X.h"
#include "VL53L0X.h"
#include "ledRead.h"
#include "RTIMULib.h"
#include "RTMath.h"
#include "SensorLib.h"

//Private Helper prototypes
//I2C Expander
int getMUXStatus(MUX *);
void setMUXStatus(MUX *, int);
int getMUXInput(MUX *);
void setMUXInput(MUX *, int);

/* I2C Expander MUX */
/*
 * Initialize the MUX
 *
 * This function initializes the I2C Expander and returns
 * a MUX object
 *
 */
MUX *initMUX() {
    MUX *newMUX = malloc(sizeof(MUX));
    char buf[15];
    int muxStatus = open(buf,0_RDWR);
    if (ioctl(muxStatus,I2C_SLAVE,0x70)<0) {
	printf("MUX initialization failed\n");
	setMUXStatus(newMUX,-1);
	return newMUX;
    }
    else {
	setMUXStatus(newMUX,0);
	switchMUX(newMUX,0);
	return newMUX;
    }
}

/*
 * Changes the active input of the I2C Expander
 * to the inputNo specified by user
 */
void switchMUX(MUX *mux, int inputNo) {
    if(!getMUXStatus(mux)) {
        char data_write[1];
        data_write[0] = 1<<inputNo;
        write(mux, data_write, 1);
	setMUXInput(mux,1);
    }
    else {
	printf("Cannot switch MUX, status error\n");
    }
}

/* VL6180X */
/*
 *
 * Initializer for the short range VL6180X TOF
 * 
 * This function initializes the TOF and returns
 * the SRANGE object
 *//Assumes the TOF is connected by MUX
 */
SRANGE *initVL6180X(MUX *mux,int inputNo) {
    SRANGE *newSRANGE = malloc(sizeof(SRANGE));
    newSRANGE->vl = Adafruit_VL6180X();
    return newSRANGE;
}

/*
 *
 * Gets the distance in mm for VL6180X
 *
 * Gets the distance from the short range TOF
 * specified by the user
 */
uint8_t getShortRange(SRANGE *srange) {
    if (!getMUXStatus(srange->mux)) {
	//switch MUX input if needed
	if (getMUXInput(srange->mux)!=srange->inputNo)
	    switchMUX(srange->mux,srange->inputNo);
	srange->range=srange->vl.readRange();
	srange->status=srange->vl.readStatus();
    }
    else {
	srange->range=-1;
	srange->status=-1;
    }
    return srange->range;
}


/* VL53L0X */
/*
 * Initializes the VL53L0X TOF
 *
 * Function returns a LRANGE object
 */
LRANGE *initLongrange(MUX *mux, int inputNo) {
    LRANGE *lrange=malloc(sizeof(LRANGE));
    VL53L0X vl;
    vl.init();
    vl.setTimeout(200);
    lrange->vl53l0x=vl;
    return lrange;
}

/*
 * Gets the distance in mm for VL53L0X
 *
 * Function gets the measured range from the user-specified
 * LRANGE object
 */
uint16_t getLongRange(LRANGE *lrange) {
    if (!getMUXStatus(mux)) {
	//switch MUX input if needed
	if (getMUXInput(mux)!=inputNo)
	    switchMUX(mux,inputNo);
    }
    uint16_t distance = lrange->vl53l0x.readRangeSingleMillimeters();
    if (lrange.timeoutOccurred())
	stdout<<"Timeout occurred. Invalid measurement.\n";
    return distance;
}


/* IRLED READER */
int readIRCode()
{
    return ledRead();
}


/* IMU */
RTIMU *imuInit() {
    //  Using RTIMULib here allows it to use the .ini file generated by RTIMULibDemo.
    //  Or, you can create the .ini in some other directory by using:
    //      RTIMUSettings *settings = new RTIMUSettings("<directory path>", "RTIMULib");
    //  where <directory path> is the path to where the .ini file is to be loaded/saved


    RTIMUSettings *settings = new RTIMUSettings("RTIMULib");

    RTIMU *imu = RTIMU::createIMU(settings);

    if ((imu == NULL) || (imu->IMUType() == RTIMU_TYPE_NULL)) {
        printf("No IMU found\n");
        exit(1);
    }

    //  This is an opportunity to manually override any settings before the call IMUInit

    //  set up IMU

    imu->IMUInit();

    //  this is a convenient place to change fusion parameters

    imu->setSlerpPower(0.02);
    imu->setGyroEnable(true);
    imu->setAccelEnable(true);
    imu->setCompassEnable(false);
    return imu;
}

double getCurrImuRoll(RTIMU *imu) {
    RTIMU_DATA imuData = imu->getIMUData();
    RTVector3 vect=imuData.fusionPose;
    double roll=vec.x() * RTMATH_RAD_TO_DEGREE;
    printf("current:%f \n",roll);
    return roll;
}

double getCurrImuPitch(RTIMU *imu) {
    RTIMU_DATA imuData = imu->getIMUData();
    RTVector3 vect=imuData.fusionPose;
    double pitch=vec.x() * RTMATH_RAD_TO_DEGREE;
    printf("current:%f \n",pitch);
    return pitch;
}

double getCurrImuYaw(RTIMU *imu) {
    RTIMU_DATA imuData = imu->getIMUData();
    RTVector3 vec=imuData.fusionPose;
    double yaw=vec.z() * RTMATH_RAD_TO_DEGREE; 
    printf("current:%f  \n",yaw);
    return yaw;
}

//Private Helper methods
int getMUXStatus(MUX *mux) {
    return mux->initVal;
}
void setMUXStatus(MUX *mux, int val) {
    mux->initVal=val;
}
int getMUXInput(MUX *mux) {
    return mux->activeInput;
}
void setMUXInput(MUX *mux, int val) {
    mux->activeInput=val;
}